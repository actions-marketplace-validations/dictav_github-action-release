// @flow

import { getInput, info, setFailed } from '@actions/core';
import { context, GitHub } from '@actions/github';

const CHANGES_HEADER = '<!-- Generated by dictav/reelease. DO NOT EDIT -->';

(async function () {
  try {
    if (context.eventName !== 'pull_request') {
      throw new Error('This action runs only for Pull Request Event');
    }

    const pld = context.payload;
    const pr = pld.pull_request;

    if (!pr) {
      throw new Error('there is no pull_request object');
    }

    info(`repo: ${JSON.stringify(context.repo)}`);
    info(`action: ${pld.action}`);
    info(`number: ${pr.number}`);
    info(`title: ${pr.title}`);
    info(`merged: ${pr.merged}`);

    const m = pr.title.match(/Release (\S+)/);
    if (!m) {
      info('this is not release pull request');
      return;
    }

    const tag_name = m[1]; // eslint-disable-line camelcase

    switch (pld.action) {
      case 'opened':
      case 'synchronize':
        info('updating body...');
        updateChanges(
          { ...context.repo, pull_number: pr.number },
          pr.body || ''
        );
        break;

      case 'closed':
        if (!pr.merged) {
          info('the pull request is closed');
          return;
        }

        info('creating a new release...');

        if (!pr.title) {
          throw new Error('title is required');
        }

        if (!pr.body) {
          throw new Error('body is required');
        }

        createNewRelease({
          ...context.repo,
          tag_name,
          name: pr.title,
          body: pr.body,
        });
        break;

      default:
        info(`unsuported action: ${pld.action}`);
        return;
    }
  } catch (err) {
    setFailed(err.message);
  }
})();

async function updateChanges(
  req /*: { owner: string, repo: string, pull_number: number } */,
  body /*: string */
) {
  const token = getInput('github-token');
  const client = new GitHub(token);

  const idx = body.indexOf(CHANGES_HEADER);

  if (idx >= 0) {
    body = body.substring(0, idx);
  }

  const { data } = await client.pulls.listCommits(req);
  const commits = data.map((a) => a.commit.message);

  if (commits.length === 0) {
    return;
  }

  body += CHANGES_HEADER + '\n';
  body += '## Changes\n';

  for (const msg of commits) {
    const m = msg.match(/Merge pull request (#\d+)\n(.*)/m);
    if (!m) {
      continue;
    }

    body += `- ${m[1]}: ${m[2]}`;
  }

  await client.pulls.update({
    ...req,
    body,
  });
}

async function createNewRelease(
  req /*: { owner: string, repo: string, tag_name: string, name: string, body: string } */
) {
  const token = getInput('github-token');
  const client = new GitHub(token);

  await client.repos.createRelease(req);
}
